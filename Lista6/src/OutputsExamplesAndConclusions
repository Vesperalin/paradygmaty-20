- QuickSort
    Time performance example:
        First example:
        *********************************** QuickSort array with 100000 elements ***********************************
        Normal quick sort: Total time: 40ms
        Future quick sort: Total time: 17ms
        Parallel quick sort: Total time: 17ms
        *********************************** QuickSort array with 1000000 elements ***********************************
        Normal quick sort: Total time: 219ms
        Future quick sort: Total time: 169ms
        Parallel quick sort: Total time: 159ms
        *********************************** QuickSort array with 10000000 elements ***********************************
        Normal quick sort: Total time: 2148ms
        Future quick sort: Total time: 1576ms
        Parallel quick sort: Total time: 1462ms

        Second Example
        *********************************** QuickSort array with 100000 elements ***********************************
        Normal quick sort: Total time: 44ms
        Future quick sort: Total time: 17ms
        Parallel quick sort: Total time: 10ms
        *********************************** QuickSort array with 1000000 elements ***********************************
        Normal quick sort: Total time: 219ms
        Future quick sort: Total time: 150ms
        Parallel quick sort: Total time: 162ms
        *********************************** QuickSort array with 10000000 elements ***********************************
        Normal quick sort: Total time: 2025ms
        Future quick sort: Total time: 1468ms
        Parallel quick sort: Total time: 1608ms

    Conclusions:
        The bigger array, the more efficient is to use some kind of parallelization. As seen above, both parallel mechanism and Future trait perform
        alike. Sometimes parallel mechanism is faster and sometimes Future is faster. But one thing is for sure, it is recommended to use some kind
        of parallelization, when huge collections must be sorted. The difference in time performance for array of 10000000 elements is huge and impressive.
        Few hundred ms is a huge gap.



-MergeSort
    Time performance example:
        First Example:
        *********************************** MergeSort array with 1000 elements ***********************************
        Normal merge sort: Total time: 78ms
        Future merge sort: Total time: 12ms
        Parallel merge sort: Total time: 11ms
        *********************************** MergeSort array with 10000 elements ***********************************
        Normal merge sort: Total time: 449ms
        Future merge sort: Total time: 352ms
        Parallel merge sort: Total time: 283ms
        *********************************** MergeSort array with 100000 elements ***********************************
        Normal merge sort: Total time: 31527ms
        Future merge sort: Total time: 24725ms
        Parallel merge sort: Total time: 23745ms

        Second example:
        *********************************** MergeSort array with 1000 elements ***********************************
        Normal merge sort: Total time: 32ms
        Future merge sort: Total time: 13ms
        Parallel merge sort: Total time: 21ms
        *********************************** MergeSort array with 10000 elements ***********************************
        Normal merge sort: Total time: 416ms
        Future merge sort: Total time: 322ms
        Parallel merge sort: Total time: 252ms
        *********************************** MergeSort array with 100000 elements ***********************************
        Normal merge sort: Total time: 31198ms
        Future merge sort: Total time: 23145ms
        Parallel merge sort: Total time: 23515ms

    Conclusions:
        First of all this algorithm is so much slower than QuickSort. The reason is that I wanted to make in-place MergeSort, because it
        saves a lot of memory, but it uses time-consuming method: putInCorrectPlace.
        Apart from that, my conclusions about time performance are nearly the same as for QuickSort. The difference for array of 100000 elements
        is about 8000/9000 ms, it is 8/9 seconds. This is enormous difference.



- ClosestPairOfPoints
    Time performance example:
        First Example:
        *********************************** ClosestPairOfPoints array with 1000 elements ***********************************
        Normal closestPairOfPoints: Total time: 147ms
        Future closestPairOfPoints: Total time: 10ms
        Parallel closestPairOfPoints: Total time: 16ms
        *********************************** ClosestPairOfPoints array with 10000 elements ***********************************
        Normal closestPairOfPoints: Total time: 291ms
        Future closestPairOfPoints: Total time: 152ms
        Parallel closestPairOfPoints: Total time: 138ms
        *********************************** ClosestPairOfPoints array with 50000 elements ***********************************
        Normal closestPairOfPoints: Total time: 5011ms
        Future closestPairOfPoints: Total time: 3013ms
        Parallel closestPairOfPoints: Total time: 3082ms


        Second Example:
        *********************************** ClosestPairOfPoints array with 1000 elements ***********************************
        Normal closestPairOfPoints: Total time: 121ms
        Future closestPairOfPoints: Total time: 10ms
        Parallel closestPairOfPoints: Total time: 10ms
        *********************************** ClosestPairOfPoints array with 10000 elements ***********************************
        Normal closestPairOfPoints: Total time: 285ms
        Future closestPairOfPoints: Total time: 163ms
        Parallel closestPairOfPoints: Total time: 138ms
        *********************************** ClosestPairOfPoints array with 50000 elements ***********************************
        Normal closestPairOfPoints: Total time: 4303ms
        Future closestPairOfPoints: Total time: 2867ms
        Parallel closestPairOfPoints: Total time: 2838ms

    Conclusions:
        The bigger array of points, the more efficient is to use some kind of parallelization. As seen above, both parallel mechanism and Future trait perform
        alike. Sometimes parallel mechanism is faster and sometimes Future is faster. These two are recommended when closest pair of points must be found
        from huge collection of points.



- Matrices Multiplication
 Time performance example:
        First Example:
        *********************************** Matrices Multiplication [10 x 20] * [20 x 30] ***********************************
        Normal multiply matrices: Total time: 38ms
        Future multiply matrices: Total time: 15ms
        Parallel multiply matrices: Total time: 16ms
        *********************************** Matrices Multiplication [100 x 200] * [200 x 300] ***********************************
        Normal multiply matrices: Total time: 301ms
        Future multiply matrices: Total time: 154ms
        Parallel multiply matrices: Total time: 185ms
        *********************************** Matrices Multiplication [1000 x 2000] * [2000 x 3000] ***********************************
        Normal multiply matrices: Total time: 176344ms
        Future multiply matrices: Total time: 102519ms
        Parallel multiply matrices: Total time: 101196ms

        Second Example:
        *********************************** Matrices Multiplication [10 x 20] * [20 x 30] ***********************************
        Normal multiply matrices: Total time: 32ms
        Future multiply matrices: Total time: 16ms
        Parallel multiply matrices: Total time: 15ms
        *********************************** Matrices Multiplication [100 x 200] * [200 x 300] ***********************************
        Normal multiply matrices: Total time: 417ms
        Future multiply matrices: Total time: 169ms
        Parallel multiply matrices: Total time: 169ms
        *********************************** Matrices Multiplication [1000 x 2000] * [2000 x 3000] ***********************************
        Normal multiply matrices: Total time: 167709ms
        Future multiply matrices: Total time: 98502ms
        Parallel multiply matrices: Total time: 97571ms

    Conclusions:
        My conclusions about time performance are the same as for QuickSort and ClosestPairOfPoints. The bigger matrices we have, the more efficient
        is to use some kind of parallelization.
