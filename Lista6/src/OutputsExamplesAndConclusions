- QuickSort
    Time performance example:
        *********************************** QuickSort array with 10000 elements ***********************************
        Normal quick sort: Total time: 10ms
        Future quick sort: Total time: 181ms
        Parallel quick sort: Total time: 10ms
        *********************************** QuickSort array with 100000 elements ***********************************
        Normal quick sort: Total time: 20ms
        Future quick sort: Total time: 13ms
        Parallel quick sort: Total time: 10ms
        *********************************** QuickSort array with 1000000 elements ***********************************
        Normal quick sort: Total time: 189ms
        Future quick sort: Total time: 147ms
        Parallel quick sort: Total time: 169ms
        *********************************** QuickSort array with 10000000 elements ***********************************
        Normal quick sort: Total time: 1805ms
        Future quick sort: Total time: 1288ms
        Parallel quick sort: Total time: 1334ms
    Conclusions:
        The bigger array, the more efficient is to use some kind of parallelization. In my case, it is better to use Feature trait, when
        huge collection must be sorted. For smaller collections it is better to use parallel mechanism or none oh them.
        The reason, why normal quick sort can be as effective as future or parallel quick sort for small collections, is that launching new threds
        can be time-absorbing and thus unprofitable.
